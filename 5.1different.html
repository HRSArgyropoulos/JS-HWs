<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>#5 Functions</title>
</head>

<body>
    <script>
        "use strict";

        /* Bugs[Fixed]: 1) [Fixed] When max on the last position(-although the code is not very clean (possibly sone nested ifs can be avoided-) 
        2) [Fixed] When input only one word 
        3) [Fixed] When input is " " (space)
        4) [Fixed] Input ___________word -> pushes every space character in words[] */

        /*Optimization: I could add " " in the end of array so we do not have a if (situation for the last element)*/

        const longestWords = (positionsobj,sentence) => {
             let words = [];
            /*
            for (const pos of positionsobj.positions) { // where the position indexes are
                let word = "";
                for (let i = 0; i < positionsobj.maxWordCount; i++) { // where the max characters of word counter is
                    word += sentence[pos + i]; 
                }
                words.push(word,pos+1); //more user friendly the n-nth position not index
            }
            */
            for (let i=0;i<positionsobj.positions.length;i++) {
                words.push(sentence.slice(positionsobj.positions[i],positionsobj.positions[i]+positionsobj.maxWordCount),positionsobj.positions[i]+1);
            }

            return words;
        };

        const longestWordsPositions = (str) => {
            //we save positions so we do not have to generate the word every time and we ll do it in longestWords function only for the max words to improve code efficiency 
            let maxWordCount = 0;
            let wordCount = 0;
            let positions = []; //array of max positions
            let curPos = 0; //the starting index of the current word
            for (let i=0; i<str.length; i++) {
                if (str[i] === ' ' || i===str.length-1) { //space between words
                    if (i===str.length-1) {wordCount++;} //for last element stop the wordcounting (end the word) -> see optimization
                    if (wordCount >= maxWordCount) {
                        if (wordCount > maxWordCount) { positions = []; } //empty array as we have a new max
                        maxWordCount = wordCount;
                        positions.push(curPos);
                    }
                    curPos += wordCount + 1; //previous position + this max word length + space character
                    wordCount = 0;
                } else { wordCount++; }
            }
            return {positions,maxWordCount}; //first we have an array of the position and then we have the length of the max word(s)
        };

        const userInput = () => {
            let input;
            while (true) {
                input = prompt('Enter a phrase').trim();
                if (input) return input;
            }
        };

        const aFunctionLikeSplit = (input) => {
            let arr=[];
            let word="";
            //input += " "; // see optimization
            for (const char of input) {
                if (char!=" ") {
                    word += char;
                } else {
                    arr.push(word);
                    word="";
                }
            }
            arr.push(word);
            return arr;
        };

        const input = userInput(); 
        console.log("Words",aFunctionLikeSplit(input));
        const wordPositions = longestWordsPositions(input);
        console.log("Positions", wordPositions.positions);
        const words = longestWords(wordPositions, input);
        console.log("Words", words);
    </script>
</body>

</html>